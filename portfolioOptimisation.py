# -*- coding: utf-8 -*-
"""portfolioanalysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fLiYhzzAHP13eKPMsufKLyycx8jHAYZY
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import datetime as dt

import yfinance as yf

# Gets close prices of stocks from yahoo finance
def get_data(stocks, start, end):
  stockData = yf.download(stocks, start=start, end=end)
  stockData = stockData['Close']
  returns = stockData.pct_change()
  meanReturns = returns.mean()
  covMatrix = returns.cov()
  return meanReturns, covMatrix
stockList = ['NVDA', 'MSFT', 'AMZN','TSLA', 'META']
endDate = dt.datetime.now()
startDate = endDate - dt.timedelta(days=300)
meanReturns, covMatrix = get_data(stockList, startDate, endDate)

#Monte Carlo Simulation
mc_sims = 10000
tf = 100

meanM = np.full(shape=(tf, len(stockList)), fill_value=meanReturns)
meanM = meanM.T

portfolio_sims = np.full(shape=(tf, mc_sims), fill_value = 0.0)
risk_free_rate = 0.02

initialPortfolio = 10000
portfolio_sims[0,:] = initialPortfolio
sharpe_ratios= np.zeros(mc_sims)
portfolio_weights = np.zeros((mc_sims,len(meanReturns)))

for n in range(0, mc_sims):
  # Generate random weights for the portfolio
  weights = np.random.random(len(meanReturns))
  weights /= np.sum(weights)
  portfolio_weights[n,:] = weights

  # Generate random normal variables
  Z = np.random.normal(size=(tf, len(weights)))
  L = np.linalg.cholesky(covMatrix)
  dailyReturns = meanM + np.inner(L,Z)
  portfolio_sims[:,n] = np.cumprod(np.inner(weights, dailyReturns.T)+1)*initialPortfolio

  # Gets the mean daily return and volatility
  portfolio_returns = portfolio_sims[1:,n]/portfolio_sims[:-1,n] -1
  mean_daily_return = np.mean(portfolio_returns)
  volatility_daily_return = np.std(portfolio_returns)

  # Annualises the returns and volatility
  annualised_return = (1+mean_daily_return) ** 252-1
  annualised_volatility = volatility_daily_return * np.sqrt(252)

  # Calculates the sharpe ratio and stores it in an array
  sharpe_ratio = (annualised_return - risk_free_rate)/ annualised_volatility
  sharpe_ratios[n] = sharpe_ratio

# Plot the simulation
plt.plot(portfolio_sims)
plt.ylabel('Portfolio Value ($)')
plt.xlabel('Days')
plt.title('MC simulation of a stock portfolio')
plt.show()

# Gets the optimal asset allocation and its sharpe ratio
max_sharpe_ratio = np.argmax(sharpe_ratios)
best_portfolio_weights = portfolio_weights[max_sharpe_ratio]
optimal_weights_dict= {stockList[i]: best_portfolio_weights[i]* 100 for i in range(len(stockList))}
print(optimal_weights_dict)